<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6（三）：变量的解构赋值]]></title>
    <url>%2F2018%2F11%2Fstructure.html</url>
    <content type="text"><![CDATA[数组的解构赋值基本用法ES6以前我们如果要定义三个变量的话需要这样做：code 123456var a = 1, b = 2, c = 3;console.log(a); // 1console.log(b); // 2console.log(c); // 3 使用解构赋值的话就好比“模式匹配”一般：code 1234let [a, b, c] = [1, 2, 3];console.log(a); // 1console.log(b); // 2console.log(c); // 3 只要等号两边的模式一样，就可以成功解构赋值：code 12345678let [ [a, [b]], c] = [ [1, [2]], 3];console.log(a); // 1console.log(b); // 2console.log(c); // 3 如果两边的模式相同，但是右边少值的话就会解构不成功，导致左边的变量值为undefined：cdoe 12345678let [ [a, [b]], c] = [ [1, []], 3];console.log(a); // 1console.log(b); // undefinedconsole.log(c); // 3 如果两边模式相同，但是左边少变量的话，依然可以将已有的变量赋值成功：cdoe 12345678let [ [a, [b]],] = [ [1, [2]], 3];console.log(a); // 1console.log(b); // 2console.log(c); // ReferenceError: c is not defined 等号的右边如果不是可遍历的机构则会报错：cdoe 123456789101112let [a] = 1;console.log(a); // TypeError: 1 is not iterablelet [a] = false;console.log(a); // TypeError: false is not iterablelet [a] = NaN;console.log(a); // TypeError: NaN is not iterablelet [a] = undefined;console.log(a); // TypeError: undefined is not iterablelet [a] = null;console.log(a); // TypeError: null is not iterablelet [a] = &#123;&#125;;console.log(a); // TypeError: &#123;&#125; is not iterable 指定默认值在解构赋值中允许指定默认值。当一个位置没有值的时候，页就是当模式相同，但是右边没有值的时候可以指定默认值： code 12345678let [ [a, [b = 4]], c] = [ [1, []], 3];console.log(a); // 1console.log(b); // 4console.log(c); // 3 注意：ES6内部使用严格相等运算符（===）判断一个位置是否有值。所以只有当一个数组成员严格等于undefined，默认值才会生效。 对象的解构赋值变量的解构赋值和数组的解构赋值不太一样： 数组的解构赋值：元素是按次序排列的，变量的取值由变量所处的位置决定对象的解构赋值：对象的属性没有次序，因此变量必须和属性同名才能取到 正确的值 *code 123let &#123; foo, bar &#125; = &#123; bar: '我是bar', foo: '我是foo' &#125;console.log(foo); // 我是fooconsole.log(bar); // 我是bar 从代码中可以看出来对象解构赋值的时候是和顺序无关的，而属性名字就显得尤为重要。 变量名与属性名不一致时如何解构赋值code 123let &#123; bar: foo &#125; = &#123; bar: '我是bar' &#125;console.log(foo); // 我是barconsole.log(bar); // ReferenceError: bar is not defined 以上代码的作用是把右边的bar解构赋值给foo，因为属性名不一样，所以需要用这种方式进行。 数组是特殊的对象由于数组是特殊的对象，所以数组也支持对象属性的解构赋值： code 12345let arr = [1, 2, 3];let &#123; 0: first, 1: second, 2: last &#125; = arr;console.log(first); // 1console.log(second); // 2console.log(last); // 3 字符串的解构赋值字符串在进行解构赋值的时候其实是被转化成为了一个类数组的对象。 code 1234567let [a, b, c, d, e, f] = 'string';console.log(a); // sconsole.log(b); // tconsole.log(c); // rconsole.log(d); // iconsole.log(e); // nconsole.log(f); // g 因为字符串具有length这个属性，因此我们还可以对该属性进行解构赋值： code 12let &#123; length: len &#125; = 'string';console.log(len); // 6 数值和布尔值的解构赋值数值和布尔值也能进行解构赋值，此时他们都被转化为了对象。 code 1234let &#123; toString: tos1 &#125; = 456;let &#123; toString: tos2 &#125; = false;console.log(tos1 === Number.prototype.toString); // trueconsole.log(tos2 === Boolean.prototype.toString); // true 函数参数的解构赋值函数的参数也可以进行解构赋值，这是一个解构赋值运用比较多的场景，其实就是对之前所讲的数组、对象、布尔值、数值解构赋值的一种实际使用： code 1234function add([a, b]) &#123; return a + b;&#125;console.log(add([2, 3])); // 5 这样做会让传参更加便捷，因为在传参的时候我们可以加入默认值，避免了a = ea || 0;这种类似的语句出现。解构赋值还是很好用的，熟悉之后会让我们的js语句更加合理，更加易于维护。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（二）：Promise]]></title>
    <url>%2F2018%2F11%2Fpromise.html</url>
    <content type="text"><![CDATA[特点Promise是一个对象，具有以下两个特点： 对象的状态不受外界影响 状态一旦改变就不会再变 使用方法基本使用ES6中规定，Promise对象是一个构造函数，于是我们就需要使用new关键字实例化： code： 1234567const promise = new Promise((resolve, reject) =&gt; &#123; if (true) &#123; resolve(successRes); &#125; else &#123; reject(errorText); &#125;&#125;); Promise接受一个函数作为参数，该函数的两个参数分别是：resolve和reject。其中: resolve可以表示异步操作成功时调用reject则可以表示异步操作失败时调用 thenPromise实例生成之后，可以使用then方法分别指定成功和失败状态的回调函数。例如： code 12345678910111213let a = 10;const promise = new Promise((resolve, reject) =&gt; &#123; if (a === 10) &#123; resolve('成功！'); &#125; else &#123; reject('失败！'); &#125;&#125;);promise.then((res) =&gt; &#123; console.log(res); // 成功！&#125;, (err) =&gt; &#123; console.log(err);&#125;); 12345678910111213let a = 0;const promise = new Promise((resolve, reject) =&gt; &#123; if (a === 10) &#123; resolve('成功！'); &#125; else &#123; reject('失败！'); &#125;&#125;);promise.then((res) =&gt; &#123; console.log(res);&#125;, (err) =&gt; &#123; console.log(err); // 失败！&#125;); 当然，then的第二个参数并不是必须的，大部分时候我们其实都只需要第一个参数（成功），而失败的回调可以放在catch中去执行。 catch比如上面返回‘失败’的例子，我们可以使用catch进行改造： code 12345678910111213let a = 10;const promise = new Promise((resolve, reject) =&gt; &#123; if (a === 10) &#123; resolve('成功！'); &#125; else &#123; reject('失败！'); &#125;&#125;);promise.then((res) =&gt; &#123; console.log(res);&#125;).catch((err) =&gt; &#123; console.log(err); //失败！&#125;); 大部分时候我们都是这样使用的 Ajax实例我们可以使用Promise对象实现一个ajax实例，这也是Promise用处最广的地方： code 123456789101112131415161718192021222324252627const myAjax = function(data, url) &#123; const promise = new Promise((resolve, reject) =&gt; &#123; const stateChange = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const myHttp = new XMLHttpRequest(); myHttp.open('GET', url, 'true'); myHttp.onreadystatechange = stateChange; myHttp.responseType = 'json'; myHttp.setRequestHeader('Accept', 'application/josn'); myHttp.send(data); &#125;); return promise;&#125;;myAjax('/uuurl').then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 其他特性新建就会立即执行code 123456789101112131415const promise = new Promise(function(resolve, reject) &#123; console.log('我是resolve之前的打印'); resolve();&#125;); promise.then(function() &#123; console.log('我是成功的回调的打印');&#125;); console.log('我是最外层的打印');// 结果：// 我是resolve之前的打印// 我是最外层的打印// 我是成功的回调的打印 结果和我们想象的一致，先是打印resolve的console，因为Promise一建立就会执行，而后进行的是最外层的打印，那是因为then指定的回调函数将在当前脚本所有同步任务执行完之后才会执行。 一个异步操作的结果是返回另一个异步操作通常情况下，reject函数的参数是Error对象的实例，表示抛出的错误；而resolve函数的参数除了正常的值以外，还可能是另一个Promise实例：code 123456const pro1 = new Promise((resolve, reject) =&gt; &#123;&#125;);const pro2 = new Promise((resolve, reject) =&gt; &#123; resolve(pro1);&#125;); 上述代码中，pro1和pro2都是Promise实例，但是pro2的resolve将pro1作为参数，此时pro1的状态就会传递给pro2，也就是说，pro1的状态决定了pro2的状态。这一点从以下代码可以很直观的看出来：code 12345678910111213141516const pro1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; return reject(new Error('err')); &#125;, 3000);&#125;);const pro2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; return resolve(pro1); &#125;, 1000);&#125;);pro2.then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;); 在这段代码中，pro1是一个Promise对象，并且在3秒之后返回Error的实例err。pro2的状态则是在1秒之后改变。由于pro2返回的是另一个Promise（pro1），导致pro2自己的状态无效了，由pro1的状态决定pro2的状态。所以最终输出的结果是： 过了3秒输出Error：err 调用resolve或reject并不会终结Promise的参数函数的执行先来看一段代码：code 123456789101112const proromise = new Promise((resolve, reject) =&gt; &#123; resolve('ok'); console.log('我是resolve后面的代码');&#125;);proromise.then(res =&gt; &#123; console.log(res);&#125;);// 结果：// 我是resolve后面的代码// ok 和预想的一样，虽然先调用了resolve(&#39;ok&#39;);，但是后面的代码还是会执行，并且会先打印出来，这是因为调用resolve或reject并不会终结Promise的参数函数的执行，而且then指定的回调函数将在当前脚本所有同步任务执行完之后才会执行。一般调用resolve和reject之后Promise的任务就完成了，所以建议在resolve和reject之后加上return。 参考链接《ECMAScript 6 入门》——阮一峰ECMAScript® 2015 Language SpecificationECMAScript® 2016 Language SpecificationECMAScript® 2019 Language Specification]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底搞懂拖拽——基于鼠标事件的拖拽以及基于HTML5 API的拖拽]]></title>
    <url>%2F2018%2F11%2Fdragdrop.html</url>
    <content type="text"><![CDATA[一、基于鼠标事件的拖拽原理——onmousedown、onmousemove、onmouseup onmousedown 该事件会在鼠标按键被按下时触发 支持该事件的HTML标签： 123456&lt;a&gt;, &lt;address&gt;, &lt;area&gt;, &lt;b&gt;, &lt;bdo&gt;, &lt;big&gt;, &lt;blockquote&gt;, &lt;body&gt;, &lt;button&gt;,&lt;caption&gt;, &lt;cite&gt;, &lt;code&gt;, &lt;dd&gt;, &lt;dfn&gt;, &lt;div&gt;, &lt;dl&gt;, &lt;dt&gt;, &lt;em&gt;, &lt;fieldset&gt;, &lt;form&gt;, &lt;h1&gt; to &lt;h6&gt;, &lt;hr&gt;, &lt;i&gt;, &lt;img&gt;, &lt;input&gt;, &lt;kbd&gt;, &lt;label&gt;, &lt;legend&gt;, &lt;li&gt;, &lt;map&gt;, &lt;ol&gt;, &lt;p&gt;, &lt;pre&gt;, &lt;samp&gt;, &lt;select&gt;, &lt;small&gt;, &lt;span&gt;, &lt;strong&gt;, &lt;sub&gt;, &lt;sup&gt;, &lt;table&gt;, &lt;tbody&gt;, &lt;td&gt;, &lt;textarea&gt;, &lt;tfoot&gt;, &lt;th&gt;, &lt;thead&gt;, &lt;tr&gt;, &lt;tt&gt;, &lt;ul&gt;, &lt;var&gt; 支持该事件的JavaScript对象： button, document, link onmousemove 该事件会在鼠标指针移动时触发 支持该事件的HTML标签： 123456&lt;a&gt;, &lt;address&gt;, &lt;area&gt;, &lt;b&gt;, &lt;bdo&gt;, &lt;big&gt;, &lt;blockquote&gt;, &lt;body&gt;, &lt;button&gt;, &lt;caption&gt;, &lt;cite&gt;, &lt;code&gt;, &lt;dd&gt;, &lt;dfn&gt;, &lt;div&gt;, &lt;dl&gt;, &lt;dt&gt;, &lt;em&gt;, &lt;fieldset&gt;, &lt;form&gt;, &lt;h1&gt; to &lt;h6&gt;, &lt;hr&gt;, &lt;i&gt;, &lt;img&gt;, &lt;input&gt;, &lt;kbd&gt;, &lt;label&gt;, &lt;legend&gt;, &lt;li&gt;, &lt;map&gt;, &lt;ol&gt;, &lt;p&gt;, &lt;pre&gt;, &lt;samp&gt;, &lt;select&gt;, &lt;small&gt;, &lt;span&gt;, &lt;strong&gt;, &lt;sub&gt;, &lt;sup&gt;, &lt;table&gt;, &lt;tbody&gt;, &lt;td&gt;, &lt;textarea&gt;, &lt;tfoot&gt;, &lt;th&gt;, &lt;thead&gt;, &lt;tr&gt;, &lt;tt&gt;, &lt;ul&gt;, &lt;var&gt; 支持该事件的JavaScript对象： 默认情况下，onmousemove不是任何对象的事件，因为鼠标移动非常频繁 onmouseup 该事件会在鼠标按键被松开时触发 支持该事件的HTML标签： 123456&lt;a&gt;, &lt;address&gt;, &lt;area&gt;, &lt;b&gt;, &lt;bdo&gt;, &lt;big&gt;, &lt;blockquote&gt;, &lt;body&gt;, &lt;button&gt;, &lt;caption&gt;, &lt;cite&gt;, &lt;code&gt;, &lt;dd&gt;, &lt;dfn&gt;, &lt;div&gt;, &lt;dl&gt;, &lt;dt&gt;, &lt;em&gt;, &lt;fieldset&gt;, &lt;form&gt;, &lt;h1&gt; to &lt;h6&gt;, &lt;hr&gt;, &lt;i&gt;, &lt;img&gt;, &lt;input&gt;, &lt;kbd&gt;, &lt;label&gt;, &lt;legend&gt;, &lt;li&gt;, &lt;map&gt;, &lt;ol&gt;, &lt;p&gt;, &lt;pre&gt;, &lt;samp&gt;, &lt;select&gt;, &lt;small&gt;, &lt;span&gt;, &lt;strong&gt;, &lt;sub&gt;, &lt;sup&gt;, &lt;table&gt;, &lt;tbody&gt;, &lt;td&gt;, &lt;textarea&gt;, &lt;tfoot&gt;, &lt;th&gt;, &lt;thead&gt;, &lt;tr&gt;, &lt;tt&gt;, &lt;ul&gt;, &lt;var&gt; 支持该事件的JavaScript对象： button, document, link 具体实现code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #test &#123; width: 100px; height: 100px; background: #000; position: absolute; color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="test"&gt;4616125&lt;/div&gt; &lt;script&gt; (function() &#123; function Code() &#123;&#125; Code.prototype = &#123; addEvent: function() &#123; var that = this; var oDiv = document.getElementById('test'); oDiv.onmousedown = function(ev) &#123; var ev = ev || event; var distanceX = ev.clientX - this.offsetLeft; var distanceY = ev.clientY - this.offsetTop; if (oDiv.setCapture) &#123; oDiv.setCapture(); &#125; document.onmousemove = function(ev) &#123; var ev = ev || event; oDiv.style.left = ev.clientX - distanceX + 'px'; oDiv.style.top = ev.clientY - distanceY + 'px'; &#125;; document.onmouseup = function(ev) &#123; document.onmousemove = document.onmouseup = null; if (oDiv.releaseCapture) &#123; oDiv.releaseCapture(); &#125; &#125;; &#125;; &#125;, init: function() &#123; var that = this; window.onload = that.addEvent; &#125;, &#125; new Code().init(); &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意事项以及存在的问题： 注意事项 被拖动的div的position属性值一定是absolute onmousedown事件需要在window.onload时加载 如果被拖动的div上有文字会有自带的文字拖动效果，需要将改div上的所有拖动事件绑定在该div上，可以使用setCapture onmousemove和onmouseup需要在onmousedown里面绑定 存在的问题 会被拖出边界 解决方案 只需要实时计算拖拽的元素边框距离上下左右屏幕之间的距离就行了，具体代码如下： code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #oDiv &#123; width: 100px; height: 100px; background-color: #000; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; 55555555555 &lt;div id="oDiv"&gt;&lt;/div&gt; &lt;script&gt; oDiv.onmousedown = function(e) &#123; var ev = e || event; var left = ev.clientX - oDiv.offsetLeft, top = ev.clientY - oDiv.offsetTop; document.onmousemove = function(e) &#123; var ev = e || event; var leftW = ev.clientX - left; var topH = ev.clientY - top; //左边不能超出 if (leftW &lt; 0) &#123; leftW = 0; &#125; //上边不能超出 if (topH &lt; 0) &#123; topH = 0; &#125; //右边不能超出 if (leftW &gt; document.documentElement.clientWidth - oDiv.offsetWidth) &#123; leftW = document.documentElement.clientWidth - oDiv.offsetWidth; &#125; //下边不能超出 if (topH &gt; document.documentElement.clientHeight - oDiv.offsetHeight) &#123; topH = document.documentElement.clientHeight - oDiv.offsetHeight; &#125; oDiv.style.left = leftW + 'px'; oDiv.style.top = topH + 'px'; &#125; document.onmouseup = function(e) &#123; document.onmousemove = null; document.onmouseup = null; &#125; return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; result： 至此使用鼠标事件的拖拽大功告成！ 二、基于HTML5拖拽API的拖拽前序知识介绍&emsp;&emsp;一个典型的拖拽操作是这样的：用户用鼠标选中一个可拖动的（draggable）元素，移动鼠标到一个可放置的（droppable）元素，然后释放鼠标。 在操作期间，会触发一些事件类型，有一些事件类型可能会被多次触发（比如drag 和 dragover 事件类型）。&emsp;&emsp;这里涉及几个知识点： 可拖动元素： 又称为源对象，是指我们鼠标点击之后准备拖动的对象（图片、div、文字等） 可放置元素： 又称为目标对象，是指可以放置源对象的区域 事件： Event On Event Handler Description drag ondrag 当拖动元素或选中的文本时触发 dragend ondragend 当拖拽操作结束时触发 (比如松开鼠标按键或敲“Esc”键) dragenter ondragenter 当拖动元素或选中的文本到一个可释放目标时触发 dragexit ondragexit 当元素变得不再是拖动操作的选中目标时触发 dragleave ondragleave 当拖动元素或选中的文本离开一个可释放目标时触发 dragover ondragover 当元素或选中的文本被拖到一个可释放目标上时触发 dragstart ondragstart 当用户开始拖动一个元素或选中的文本时触发 drop ondrop 当元素或选中的文本在可释放目标上被释放时触发 ps：当从操作系统向浏览器中拖动文件时，不会触发dragstart 和dragend 事件 接口： HTML5为所有的拖动相关事件提供了一个新的属性： 源对象和目标对象的事件间传递数据ev.dataTransfer {}//数据传递对象源对象上的事件处理中保存数据：ev.dataTransfer.setData(key,value);//key,value必须都是字符串类型目标对象上的事件处理中读取数据：var value2 = ev.dataTransfer.getData(key); 兼容性 ps：图片来源（CAN I USE?） 具体实现代码code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type="text/css"&gt; #thatDiv &#123; width: 500px; height: 100px; border: 1px solid red; position: relative; &#125; #thisDiv &#123; width: 500px; height: 100px; border: 1px solid black; margin-bottom: 20px; &#125; #tarDiv, #tarDiv1, #tarDiv2, #tarDiv3, #tarDiv4 &#123; float: left; width: 50px; height: 50px; background-color: #000; border: 1px #fff solid; &#125; .tarDiv &#123; color: #fff; text-align: center; line-height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="thisDiv"&gt; &lt;div id="tarDiv" class="tarDiv" draggable="true"&gt;1&lt;/div&gt; &lt;div id="tarDiv1" class="tarDiv" draggable="true"&gt;2&lt;/div&gt; &lt;div id="tarDiv2" class="tarDiv" draggable="true"&gt;3&lt;/div&gt; &lt;div id="tarDiv3" class="tarDiv" draggable="true"&gt;4&lt;/div&gt; &lt;div id="tarDiv4" class="tarDiv" draggable="true"&gt;5&lt;/div&gt; &lt;/div&gt; &lt;div id="thatDiv"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var tarDiv = document.getElementsByClassName("tarDiv"); var thisDiv = document.getElementById("thisDiv"); var thatDiv = document.getElementById("thatDiv"); thisDiv.ondragstart = function(ev) &#123; var ev = ev || window.event; ev.dataTransfer.setData("text", ev.target.id); //将被拖拽的元素的id存入dataTransfer对象中 window.thisId = ev.target.id; ev.dataTransfer.effectAllowed = "copy"; &#125; thatDiv.ondragover = function(ev) &#123; //阻止dragover的默认事件 var ev = ev || window.event; if (typeof ev.preventDefault == "function") &#123; ev.preventDefault(); &#125; else &#123; ev.returnValue = false; &#125; var div = document.getElementById(window.thisId); thatDiv.appendChild(div); div.style.cssText = "border:1px #fff dashed;"; ev.preventDefault(); ev.dataTransfer.dropEffect = "copy"; &#125; thatDiv.ondragenter = function(ev) &#123; //阻止dragenter的默认事件 var ev = ev || window.event; if (typeof ev.preventDefault == "function") &#123; ev.preventDefault(); &#125; else &#123; ev.returnValue = false; &#125; &#125; thatDiv.ondragleave = function(ev) &#123; var ev = ev || window.event; var removeDiv = document.getElementById(window.thisId); thatDiv.removeChild(removeDiv); thisDiv.appendChild(removeDiv); removeDiv.style.cssText = "border:1px #fff solid;"; ev.preventDefault(); &#125; thatDiv.ondrop = function(ev) &#123; var ev = ev || window.event; var divId = ev.dataTransfer.getData("Text"); //从dataTransfer对象中取出数据 if (typeof ev.preventDefault == "function") &#123; //阻止drop事件的默认行为 ev.preventDefault(); &#125; else &#123; ev.returnValue = false; &#125; var moveDiv = document.getElementById(divId); thatDiv.appendChild(moveDiv); moveDiv.setAttribute('draggable', 'false'); moveDiv.style.cssText = "border:1px #fff solid;"; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; result： 参考资料 w3school在线教程]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉语拼音转换（hàn yǔ pīn yīn zhuǎn huàn）]]></title>
    <url>%2F2018%2F11%2F%E6%B1%89%E5%AD%97%E8%BD%AC%E6%8B%BC%E9%9F%B3.html</url>
    <content type="text"><![CDATA[插件介绍 名称： pinyin 特性： 根据词组智能匹配最正确的拼音支持多音字简单的繁体支持支持多种不同拼音风格 安装： npm install pinyin 开始使用简单使用code： let pinyin = require("pinyin"); console.log(pinyin("汉语拼音转换，真高兴")); result： Array (9 items) 0: ["han"] 1: ["zi"] 2: ["zhuan"] 3: ["pin"] 4: ["yin"] 5: ["，"] 6: ["zhen"] 7: ["gao"] 8: ["xing"] Array Prototype 可以看出来，使用方式很简单：pinyin(words[, options])，转换的结果是以数组的形式输出的。 加上音节code： let pinyin = require("pinyin") console.log(pinyin("汉字转拼音，真高兴",{ style:pinyin.STYLE_TONE })); result： Array (9 items) 0: ["hàn"] 1: ["zì"] 2: ["zhuǎn"] 3: ["pīn"] 4: ["yīn"] 5: ["，"] 6: ["zhēn"] 7: ["gāo"] 8: ["xīng"] Array Prototype 已经为文字加上音节了，这里需要多说一句，加音节的语法是：&lt;Object&gt; options.style，可以通过以下几种 STYLE_ 开头的静态属性进行指定： 静态属性 .STYLE_NORMAL 普通风格，即不带音标。如：pin yin .STYLE_TONE 声调风格，拼音声调在韵母第一个字母上。注：这是默认的风格。如：pīn yīn .STYLE_TONE2 声调风格 2，即拼音声调以数字形式在各个拼音之后，用数字 [0-4] 进行表示。如：pin1 yin1 .STYLE_TO3NE 声调风格 3，即拼音声调以数字形式在注音字符之后，用数字 [0-4] 进行表示。如：pi1n yi1n .STYLE_INITIALS 声母风格，只返回各个拼音的声母部分。对于没有声母的汉字，返回空白字符串。如：中国 的拼音 zh g注：声明风格会区分 zh 和 z，ch 和 c，sh 和 s。注意：部分汉字没有声母，如 啊，饿 等，另外 y, w, yu 都不是声母， 这些汉字的拼音声母风格会返回 “”。请仔细考虑你的需求是否应该使用首字母风格。 详情请参考 为什么没有 y, w, yu 几个声母 .STYLE_FIRST_LETTER 首字母风格，只返回拼音的首字母部分。如：p y 多音字模式和分词模式仔细观察刚刚的结果会发现：最后两个字“高兴”的拼音是错的。 &lt;Boolean&gt; options.segment 是否启用分词模式，中文分词有助于极大的降低多音字问题。 但性能会极大的下降，内存也会使用更多。 &lt;Boolean&gt; options.heteronym 是否启用多音字模式，默认关闭。关闭多音字模式时，返回每个汉字第一个匹配的拼音。启用多音字模式时，返回多音字的所有拼音列表。 code： let pinyin = require("pinyin") console.log(pinyin("汉字转拼音，真高兴", { style:pinyin.STYLE_TONE, heteronym: true, // 启用多音字模式 segment: true // 启用分词，以解决多音字问题。 })); result： Array (9 items) 0: ["hàn"] 1: ["zì"] 2: ["zhuǎn"] 3: ["pīn"] 4: ["yīn"] 5: ["，"] 6: ["zhēn"] 7: ["gāo"] 8: ["xìng"] Array Prototype 现在就行了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断两个json是否相等]]></title>
    <url>%2F2018%2F11%2F2.html</url>
    <content type="text"><![CDATA[原理 暴力的递归遍历对比，遇到不相等就return false code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let jsonObjA = &#123; "Name": "MyName", "Company": "MyCompany", "Infos": [&#123; "Age": "100" &#125;, &#123; "Box": [&#123; "Height": "100" &#125;, &#123; "Weight": "200" &#125;] &#125;], "Address": "undefined"&#125;;let jsonObjB = &#123; "Name": "MyName", "Company": "MyCompany", "Infos": [&#123; "Age": "100" &#125;, &#123; "Box": [&#123; "Height": "100" &#125;, &#123; "Weight": "200" &#125;] &#125;], "Address": "undefined"&#125;;function compreObj(obj1, obj2) &#123; var flag = true; function compre(obj1, obj2) &#123; if (Object.keys(obj1).length != Object.keys(obj2).length) &#123; flag = false; &#125; else &#123; for (let x in obj1) &#123; if (obj2.hasOwnProperty(x)) &#123; if (obj1[x] !== obj2[x]) &#123; compre(obj1[x], obj2[x]); &#125; &#125; else &#123; flag = false; &#125; &#125; &#125; if (flag === false) &#123; return false; &#125; else &#123; return true; &#125; &#125; return compre(obj1, obj2)&#125;console.log(compreObj(jsonObjA, jsonObjB));]]></content>
      <categories>
        <category>JSON</category>
      </categories>
      <tags>
        <tag>JSON JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（一）：let和const]]></title>
    <url>%2F2018%2F10%2Fletandconst.html</url>
    <content type="text"><![CDATA[一、let1. let基本用法&emsp;&emsp;相当于var,但是又与var不同，因为let声明的变量只能在let所在的代码块中有效。&emsp;&emsp;从以下两段代码以及对应的输出结果可以很明显的看出var与let的区别。code： 1234for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;console.log(i); result： 123456012345 code： 1234for (let i = 0; i &lt; 5; i++) &#123; console.log(i);&#125;console.log(i); result： 12345601234ReferenceError: i is not defined 2. 块级作用域&emsp;&emsp;众所周知，在ES5中只有全局作用域和函数作用域，没有我们所谓的块级作用域。&emsp;&emsp;这不禁让我想起一个面试题：code： 1234567for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;console.log(new Date, i); &emsp;&emsp;问：上面这段代码输出的结果是什么？&emsp;&emsp;仔细琢磨一下我们很容易得出正确的答案： result： 1234562018-10-31T06:55:30.020Z 52018-10-31T06:55:31.021Z 52018-10-31T06:55:31.021Z 52018-10-31T06:55:31.022Z 52018-10-31T06:55:31.022Z 52018-10-31T06:55:31.022Z 5 &emsp;&emsp;仔细看一下发现：由于setTimeout会被JavaScript延迟执行，因此是先输出最底部的console.log，隔一秒之后再执行循环里面的consol.log,此时i已经全部是5。&emsp;&emsp;那我们怎么样才能使输出结果变成想要的0,1,2,3,4呢？&emsp;&emsp;明白了let的原理之后其实问题变得很简单：code： 1234567for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125;console.log(new Date, i); &emsp;&emsp;这样就行了吗？result： 1ReferenceError: i is not defined &emsp;&emsp;哈哈，刚刚还说过let只在所在的代码块里面有效，这里最外层的console.log很明显找不到i，所以报出引用错误。想要得到正确答案其实还需要去掉最后一行console.log。&emsp;&emsp;当然这个题目要搁以前的话，首先想到的解决方案应该是IIFE（Immediately Invoked Function Expression：声明即执行的函数表达式）来解决闭包造成的问题。code： 123456789for (var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(new Date, j); &#125;, 1000); &#125;)(i);&#125;console.log(new Date, i); result： 1234562018-10-31T07:17:45.825Z 52018-10-31T07:17:46.827Z 02018-10-31T07:17:46.827Z 12018-10-31T07:17:46.827Z 22018-10-31T07:17:46.827Z 32018-10-31T07:17:46.827Z 4 &emsp;&emsp;由此我们是不是就可以得出一个结论，有了let，我们就可以抛弃IIFE了？&emsp;&emsp;这个暂时还不好说，我们还是继续看看let的其他特性。 3. 没有变量提升&emsp;&emsp;var命令会产生变量提升的现象，这使得js这门语言变得并不严谨，这一点是特点也是鸡肋。用var声明的变量，如果我们在声明之前使用，则它的值为undefined。&emsp;&emsp;而当我们用let定义变量时，就必须严格按照先定义再使用的原则了，反之则会抛出一个大大的引用错误（ReferenceError），显然这更符合人们的使用习惯。code： 12345console.log(a);var a = 2;console.log(b);let b = 2; result： 12undefinedReferenceError: b is not defined 4. 暂时性死区及不能重复声明&emsp;&emsp;ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。&emsp;&emsp;总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。&emsp;&emsp;“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。&emsp;&emsp;let不允许在相同作用域内，重复声明同一个变量。 二、const1. const基本用法&emsp;&emsp;const命令是声明一个常量，用法和let一样。 和let的相同之处是： const与let作用域相同，都是只在声明的代码块中起作用 const也不会提升所声明的常量 const也不能重复声明 不同之处是const声明的常量在声明时就必须赋值，因为一旦声明就不能改变改常量的值 2. 真的不能改变吗？&emsp;&emsp;const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。code&amp;result： 12345678const a=1;a=2;//TypeErrorconst obj=&#123; b:3, c:4&#125;obj.b=5;console.log(obj);//&#123;b:5,c:4&#125; 参考资料 《ECMAScript 6 入门》——阮一峰 破解前端面试（80% 应聘者不及格系列）：从闭包说起——王仕军知乎专栏：前端周刊 ECMAScript2015官方标准]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElementUI的DatePicker多个日期选择器默认没有选中样式的问题]]></title>
    <url>%2F2018%2F10%2F1.html</url>
    <content type="text"><![CDATA[背景&emsp;&emsp;在使用vue+element开发的时候由于项目需要，需要使用element日期选择器里面的支持多选以及跳选的日期选择器。&emsp;&emsp;就是这货：code： 12&lt;el-date-picker v-model="value13" type="dates"&gt;&lt;/el-date-picker&gt; &emsp;&emsp;它可以支持跳选，还是一个比较实用的日期选择器： 问题&emsp;&emsp;在使用过程中发现一个很蛋疼的问题，该日期选择器并不会按照预想的点击之后将默认填充的日期选中： 解决&emsp;&emsp;历经千辛万苦无法解决，只好去官方GitHub提issue，很快得到回复。原来因为dates的取值是每一天的0点整,传入的默认值是当前时间,与0点不同 所以没有应用选中样式，如果要默认选择当天,默认值请设置为 new Date(new Date().setHours(0,0,0,0))。code： 12345data() &#123; return &#123; value13: [new Date(new Date().setHours(0,0,0,0))] &#125;; &#125; &emsp;&emsp;这样就行了！ jsfiddle在线测试地址]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机H5页面]]></title>
    <url>%2F2018%2F09%2F3.html</url>
    <content type="text"><![CDATA[文字滚动使用li标签，通过改变margin-top实现向上滚动。 代码： js: 123456789101112131415161718192021222324252627carousel: function() &#123; var items = $('.roll').find('li'); console.log(items); var $itemOne = items.eq(0); var margin_top = 0; var margin_top_height = $itemOne.height(); var lastitems = margin_top_height * items.length; var stay_time = 2000; //停留时间 var current_time = 0; if (items.length &gt; 0) &#123; setInterval(function() &#123; if (margin_top % margin_top_height == 0) &#123; //停留 current_time += 50; if (current_time &lt;= stay_time) &#123; return; &#125; current_time = 0; &#125; margin_top += 1; if (margin_top == lastitems) &#123; margin_top = 0; &#125; $itemOne.css('margin-top', '-' + margin_top + 'px'); &#125;, 50); &#125;&#125;, html: 1234567891011121314151617181920&lt;ul class="roll_width"&gt; &lt;li&gt; &lt;span class="&gt;&lt;img class="" src="images/img.png" alt=""&gt;&lt;/span&gt; &lt;span class=""&gt;张三&lt;/span&gt; &lt;span class=""&gt;男&lt;/span&gt; &lt;span class=""&gt;25&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=""&gt;&lt;img class="" src="images/img.png" alt=""&gt;&lt;/span&gt; &lt;span class="setwidth"&gt;李四&lt;/span&gt; &lt;span class="setwidth3"&gt;男&lt;/span&gt; &lt;span class="setwidth2"&gt;25&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=""&gt;&lt;img class="" src="images/img.png" alt=""&gt;&lt;/span&gt; &lt;span class=""&gt;王五&lt;/span&gt; &lt;span class=""&gt;男&lt;/span&gt; &lt;span class=""&gt;35&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; 手机页面适配各种屏幕使用手淘团队的flexible： &lt;script src=&quot;https://s4.ssl.qhres.com/!9259ca14/flexible.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://lib.baomitu.com/zepto/1.2.0/zepto.min.js&quot;&gt;&lt;/script&gt; jQuery ajax包含cookie123456789101112131415161718$.ajax(&#123; url: url, data: ret, type: "GET", async: true, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, dataType: 'json', timeout: 2000, success: function(ret) &#123; &#125;, error: function(xhr, type) &#123; &#125; &#125;);]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js操作Excel表格]]></title>
    <url>%2F2018%2F09%2Fjsexcel.html</url>
    <content type="text"><![CDATA[js-ExcelJs is used to operate Excel tables and realize automatic summation. 使用js对在网页中打开Excel表格，并进行自动求和操作。 使用的插件：js-xlsx代码地址：https://github.com/usecodelee/js-Excel兼容性如图： 操作演示： 初始页面： 打开Excel表格（可以点击选择文件，也可以直接将文件拖动到输入框） 可以看见行数列数等信息 输入需要求和的列名，得出求和结果 如果表格中含有非数字 如果有非数字会提示 然后也能计算出来去除非数字后的正确结果 原始的Excel表格]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现斐波那契数列]]></title>
    <url>%2F2018%2F09%2Ffibonacci.html</url>
    <content type="text"><![CDATA[背景——兔子数列假设第1个月有1对刚诞生的兔子，第2个月进入成熟期，第3个月开始生育兔子，而1对成熟的兔子每个月会生1对兔子，兔子永远不会死去……那么，由1对兔子开始，12个月后会有多少对兔子呢？ 问题分析：我们拿新出生的1对小兔子分析， 第1个月，小兔子a没有繁殖能力，所以还是1对。 第2个月，小兔子a进入成熟期，仍然是1对。 第3个月，兔子a生了1对小兔子b，于是这个月共有2（1+1）对兔子。 第4个月，兔子a又生了1对小兔子c，因此共有3（1+2）对兔子。 第5个月，兔子a又生了1对兔子d，而在第3个月出生的兔子b也生下了1对小兔子e，于是共有5（2+3）对兔子 …… 从分析中可以看出，这个数列有一个很明显的特点，即从第3个月开始，当月的兔子数＝上月兔子数+当月新生兔子数，而当月新生的兔子数正好是上上个月的兔子数。因此：当月的兔子数=上月兔子数+上上月兔子数。这就是著名的斐波那契数列，又称为黄金分割数列。 斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 35 … 表达式为： 算法设计 递归——简单粗暴 代码： 12345678910/* 递归 */function fb1(n) &#123; if (n &lt; 1) return -1; if (n == 1 || n == 2) return 1; return fb1(n - 1) + fb1(n - 2);&#125;console.log(fb1(12));//144 时间复杂度：O(2^N)空间复杂度：O(N)时间复杂度是指数阶，属于爆炸增量函数，在程序设计中我们应该避免这样的复杂度。 改进——空间换时间 第一种解法比较简单，但是多个元素重复计算，因而时间复杂度较高，为了避免重复计算，可进行数组保存一下每一次计算的结果，减少时间复杂度。 代码： 12345678910111213 /* 数组 */function fb2(n) &#123; if (n &lt; 1) return -1; if (n == 1 || n == 2) return 1; var res = [1, 1]; for (var i = 2; i &lt; n; i++) &#123; res[i] = res[i - 1] + res[i - 2]; &#125; return res[n - 1];&#125;console.log(fb2(12));//144 时间复杂度：O(2^N)空间复杂度：O(N) 改进——降空间复杂度 观察第二种解法，其实我们只需要得到第n个斐波那契数，中间结果只是为了下一次计算使用，根部不需要记录。因此可以再次优化。 代码： 1234567891011121314151617/* 迭代 */function fb3(n) &#123; let num1 = 1, num2 = 2, num3 = 0; if (n &lt; 1) return -1; if (n == 1 || n == 2) return 1; for (let i = 3; i &lt; n; i++) &#123; num3 = num1 + num2; num1 = num2; num2 = num3 &#125; return num3&#125;console.log(fb3(12));//144 时间复杂度：O(N) 空间复杂度：O(1) 生活中的斐波那契数列科学研究发现植物的叶、枝、茎的排列很多符合斐波那契数列！向日葵的种子圈数和种子数，菠萝外表排序等。植物的枝丫也满足斐波那契数列，这就是生物学中的“鲁德维个定律”。 植物并不懂得斐波那契数列，这是自然选择的结果，这些植物的排列方式可以使得植物种子大小相近而且疏密得当。这就需要我们自然界最美好的数，黄金分割数：0.618！ 再看我们的斐波那契数列，它是一个自然数的数列，然而通项公式却是用无理数来表达的。而且当n趋向于无穷大时，斐波那契数列前一项和后一项的比值越来越接近黄金分割比0.618！ 参考书籍：《趣学算法》——陈小玉著]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript小知识点（二）]]></title>
    <url>%2F2018%2F08%2Ftwojs.html</url>
    <content type="text"><![CDATA[五、匹配特定的字符串，让其突出显示12345var subStr = "abc";var reg = new RegExp("(" + subStr + ")", "g");var str = "dsafadfdsfabsabcfefaefeabcfdsfafefaefaes";var newstr = str.replace(reg, "&lt;font color=red&gt;$1&lt;/font&gt;");document.write(newstr); 六、格式化输出json12JSON.stringify(object,null,2)JSON.stringify(object,undefined,2) 其中第三个参数表示指定缩进用的空白字符串 七、jQuery中，某个元素被点击之后hover失效使用jQuery的click为某元素加上css样式，之后该元素原有的hover事件失效，原因是click加上的css权值比外联的css权值大。所以是点击之后原有css被覆盖了。解决方法也很简单，为原有的css hover样式加上!important。 八、word-wrap:break-word和word-break:break-allword-wrap:break-word表示超出部分按单词截断，会保持单词的完整。word-break:break-all则会从单词中间截断。word-wrap无效的情况： 对行内元素无效 设置了white-space:nowrap时无效，需将white-space设置为normal 对table下的td设置无效]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript小知识点（一）]]></title>
    <url>%2F2018%2F08%2Fonejs.html</url>
    <content type="text"><![CDATA[一、回到顶部方法： 锚点 scrollTop scrollTo scrollBy scrollIntoView 减速效果：code：123456789101112$('#back-to-top').click(function() &#123; var target = 0; clearInterval(timer); var timer = setInterval(function() &#123; target = $(this).scrollTop(); target -= Math.ceil(target / 10); window.scrollTo(0, target); if (target == 0) &#123; clearInterval(timer); &#125; &#125;, 10);&#125;); 二、$(window).scroll()禁用和启用 禁用：$(window).off(&#39;scroll&#39;，handle)其中handle是滚动绑定的函数。 启用：绑定的时候如果使用的是匿名函数，则需要将该函数重写一次。如果不是匿名函数的话直接执行该函数。 三、鼠标滚动到指定位置才显示某元素code：12345678$(window).scroll(function() &#123; var scrollTop = $(this).scrollTop(); if (scrollTop &gt; 500) &#123; $('#myTab').slideDown(); &#125; else &#123; $('#myTab').slideUp(); &#125;&#125;); 其中scrollTop表示该元素距离顶部的距离。 四、使用jQuery判断字符串是不是json格式的code：12345678function isJson( str ) &#123; try &#123; $.parseJSON(str); &#125; catch (e) &#123; return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setTimeout定时器以及部分知识点]]></title>
    <url>%2F2018%2F07%2Fsettimeout.html</url>
    <content type="text"><![CDATA[难点： 按固定格式输出（hh:mm:ss） 开始，暂停，开始 解决多次点击开始会使定时器速度加快的问题 1. 按固定格式输出123function formatNumber(num) &#123; return num &lt; 10 ? '0' + num : num; &#125; 思路：在每次输出之前格式化一下数据，使用三元运算符，如果小于10就在前面补0 2. 开始，暂停，开始1234567891011121314151617181920212223var flag = 1;function Timer() &#123; flag = 1; if (flag == 1) &#123; if (sec &lt;= 59 &amp;&amp; sec &gt;= 0 &amp;&amp; min &lt;= 59 &amp;&amp; min &gt;= 0 &amp;&amp; hou &lt;= 59 &amp;&amp; hou &gt;= 0) &#123; document.getElementById('showTime').innerHTML = formatN(hou) + ":" + formatN(min) + ":" + formatN(sec); sec = sec + 1; &#125; else if (min &lt;= 59 &amp;&amp; min &gt;= 0 &amp;&amp; hou &lt;= 59 &amp;&amp; hou &gt;= 0) &#123; min = min + 1; sec = 0; &#125; else if (hou &lt;= 59 &amp;&amp; hou &gt;= 0) &#123; hou = hou + 1; min = 0; sec = 0; &#125; window.timer = setTimeout("Timer()", 1000); &#125;&#125;function stop() &#123; clearTimeout(timer); flag = 0;&#125; 思路：加一个标记flag，开始执行之后改变flag为原来的值并启动定时器，暂停的时候改变flag的值 3. 解决多次点击开始会使定时器速度加快的问题出现这个问题的原因：假如你在0时刻点击了一下按钮，那么500ms时数字会跳一下，1000ms会再跳一下，依次类推，1500，2000，2500…..的时候都会跳一下，时间间隔始终是500ms，但是，假如你在300ms的时候又点击了一下按钮，那么800ms的时候数字就会跳一下，1300，1800，2300…..的时侯都会跳一下，那么现在看0到2000ms之间，300，500，800，1000，1300，1500，1800，2000时刻时数字都会跳一下，数字变化的时间间隔自然会变小，同理，你点击的次数越多，时间间隔就会越小。 解决方案：每次启动定时器的时候先清一下定时器（clearTimeout()）,此时会有另一个问题，先清定时器会报错：定时器未定义，解决方法是： 12if(window.t) clearTimeout(window.t); window.t = setTimeout(..... ); window上即使未定义也不会报错。 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #showTime &#123; color: red; font-size: 30px; font-weight: 700; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;setTimeout实现计时器&lt;/h1&gt; &lt;script&gt; var sec = 0; var min = 0; var hou = 0; var flag = 1; function Timer() &#123; flag = 1; if (flag == 1) &#123; if (sec &lt;= 59 &amp;&amp; sec &gt;= 0 &amp;&amp; min &lt;= 59 &amp;&amp; min &gt;= 0 &amp;&amp; hou &lt;= 59 &amp;&amp; hou &gt;= 0) &#123; document.getElementById('showTime').innerHTML = formatNumber(hou) + ":" + formatNumber(min) + ":" + formatNumber(sec);; sec = sec + 1; &#125; else if (min &lt;= 59 &amp;&amp; min &gt;= 0 &amp;&amp; hou &lt;= 59 &amp;&amp; hou &gt;= 0) &#123; min = min + 1; sec = 0; &#125; else if (hou &lt;= 59 &amp;&amp; hou &gt;= 0) &#123; hou = hou + 1; min = 0; sec = 0; &#125; if (window.timer) &#123; clearTimeout(timer); &#125; window.timer = setTimeout("Timer()", 1000); &#125; &#125; function formatNumber(num) &#123; return num &lt; 10 ? '0' + num : num; &#125; function stop() &#123; clearTimeout(timer); flag = 0; &#125; &lt;/script&gt; &lt;button onclick="Timer()"&gt;开始计时&lt;/button&gt; &lt;button onclick="stop()"&gt;暂停计时&lt;/button&gt; &lt;p id="showTime"&gt;00:00:00&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 运行结果：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现截图并保存图片在本地]]></title>
    <url>%2F2018%2F07%2Fhtmltoimg.html</url>
    <content type="text"><![CDATA[html转canvas、canvas转image需要的库html2canvas.js和canvas2image.js话不多说，直接上代码！ codeHTML： 12345678910111213141516171819202122232425262728293031323334&lt;h2&gt;原始HTML&lt;/h2&gt;&lt;div style="background:red;width: 600px;" class="test"&gt; &lt;div style="background:green;"&gt; &lt;div style="background:blue;"&gt; &lt;div style="background:yellow;"&gt; &lt;div style="background:orange;"&gt; 33333333333333333333333333333333 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;h2 class="toCanvas"&gt; &lt;a href="javascript:void(0);"&gt; 转成canvas &lt;/a&gt;&lt;/h2&gt;&lt;h2 class="toPic"&gt; &lt;a href="javascript:void(0);"&gt; 转成图片 &lt;/a&gt;&lt;/h2&gt;&lt;h5&gt; &lt;label for="imgW"&gt;宽度:&lt;/label&gt; &lt;input type="number" value="" id="imgW" placeholder="默认是原图宽度" /&gt; &lt;label for="imgH"&gt;高度:&lt;/label&gt; &lt;input type="number" value="" id="imgH" placeholder="默认是原图高度" /&gt; &lt;label for="imgFileName"&gt;文件名:&lt;/label&gt; &lt;input type="text" placeholder="文件名" id="imgFileName" /&gt; &lt;select id="sel"&gt; &lt;option value="png"&gt;png&lt;/option&gt; &lt;option value="jpeg"&gt;jpeg&lt;/option&gt; &lt;option value="bmp"&gt;bmp&lt;/option&gt; &lt;/select&gt; &lt;button id="save"&gt;保存&lt;/button&gt;&lt;/h5&gt; CSS：1234567891011121314151617181920 &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; padding: 20px; border: 5px solid black; &#125; h2 &#123; background: #efefef; margin: 10px; &#125; .toPic &#123; display: none; &#125;&lt;/style&gt; JS：12345678910111213141516171819202122232425262728293031323334353637383940&lt;script type="text/javascript" src="jquery-3.3.1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="html2canvas.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="canvas2image.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var test = $(".test").get(0); //将jQuery对象转换为dom对象 // 点击转成canvas $('.toCanvas').click(function (e) &#123; // 调用html2canvas插件 html2canvas(test).then(function (canvas) &#123; // canvas宽度 var canvasWidth = canvas.width; // canvas高度 var canvasHeight = canvas.height; // 渲染canvas $('.toCanvas').after(canvas); // 显示‘转成图片’按钮 $('.toPic').show(1000); // 点击转成图片 $('.toPic').click(function (e) &#123; // 调用Canvas2Image插件 var img = Canvas2Image.convertToImage(canvas, canvasWidth, canvasHeight); // 渲染图片 $(".toPic").after(img); // 点击保存 $('#save').click(function (e) &#123; let type = $('#sel').val(); //图片类型 let w = $('#imgW').val(); //图片宽度 let h = $('#imgH').val(); //图片高度 let f = $('#imgFileName').val(); //图片文件名 w = (w === '') ? canvasWidth : w; //判断输入宽高是否为空，为空时保持原来的值 h = (h === '') ? canvasHeight : h; // 调用Canvas2Image插件 Canvas2Image.saveAsImage(canvas, w, h, type, f); &#125;); &#125;); &#125;); &#125;);&lt;/script&gt; 代码都有详细的注释，就不一一介绍了。下面来看看效果： result首先原始HTML里面的内容是需要截图的： 点击转成canvas： 可以看见此时增加一个一个canvas标签： 点击转成图片： 可以看见此时增加一个一个img标签： 点击保存： 至此，js截图就做完了。 html2canvas.js和canvas2image.js的下载地址：html2canvas.js:http://html2canvas.hertzen.com/dist/html2canvas.min.jscanvas2image.js:https://github.com/SuperAL/canvas2image 源码地址github：https://github.com/usecodelee/JavaScript-screenshot]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESLint配置信息]]></title>
    <url>%2F2018%2F07%2Feslintall.html</url>
    <content type="text"><![CDATA[说明： &quot;no-undef&quot;: 0,和&quot;no-undef&quot;: &#39;off&#39;,一样，表示关闭该功能 &quot;no-undef&quot;: 1, 表示仅提示 &quot;no-undef&quot;: 2, 表示报错 配置信息（来自网络） &quot;no-alert&quot;: 0,//禁止使用alert confirm prompt &quot;no-array-constructor&quot;: 2,//禁止使用数组构造器 &quot;no-bitwise&quot;: 0,//禁止使用按位运算符 &quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee &quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名 &quot;no-class-assign&quot;: 2,//禁止给类赋值 &quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句 &quot;no-console&quot;: 2,//禁止使用console &quot;no-const-assign&quot;: 2,//禁止修改const声明的变量 &quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1) &quot;no-continue&quot;: 0,//禁止使用continue &quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符 &quot;no-debugger&quot;: 2,//禁止使用debugger &quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符 &quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/ &quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 {a:1,a:1} &quot;no-dupe-args&quot;: 2,//函数参数不能重复 &quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复 &quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句 &quot;no-empty&quot;: 2,//块语句中的内容不能为空 &quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空 &quot;no-empty-label&quot;: 2,//禁止使用空label &quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符 &quot;no-eval&quot;: 1,//禁止使用eval &quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值 &quot;no-extend-native&quot;: 2,//禁止扩展native对象 &quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定 &quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换 &quot;no-extra-parens&quot;: 2,//禁止非必要的括号 &quot;no-extra-semi&quot;: 2,//禁止多余的冒号 &quot;no-fallthrough&quot;: 1,//禁止switch穿透 &quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3. &quot;no-func-assign&quot;: 2,//禁止重复的函数声明 &quot;no-implicit-coercion&quot;: 1,//禁止隐式转换 &quot;no-implied-eval&quot;: 2,//禁止使用隐式eval &quot;no-inline-comments&quot;: 0,//禁止行内备注 &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数） &quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式 &quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量 &quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格1.&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性 &quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同 &quot;no-labels&quot;: 2,//禁止标签声明 &quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块 &quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句 &quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） &quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型 &quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格 &quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格 &quot;no-multi-spaces&quot;: 1,//不能用多余的空格 &quot;no-multi-str&quot;: 2,//字符串不能用\换行 &quot;no-multiple-empty-lines&quot;: [1, {&quot;max&quot;: 2}],//空行最多不能超过2行 &quot;no-native-reassign&quot;: 2,//不能重写native对象 &quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有! &quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算 &quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值 &quot;no-new-func&quot;: 1,//禁止使用new Function &quot;no-new-object&quot;: 2,//禁止使用new Object() &quot;no-new-require&quot;: 2,//禁止使用new require &quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number &quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON() &quot;no-octal&quot;: 2,//禁止使用八进制数字 &quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列 &quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值 &quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接 &quot;no-plusplus&quot;: 0,//禁止使用++，-- &quot;no-process-env&quot;: 0,//禁止使用process.env &quot;no-process-exit&quot;: 0,//禁止使用process.exit() &quot;no-proto&quot;: 2,//禁止使用__proto__属性 &quot;no-redeclare&quot;: 2,//禁止重复声明变量 &quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ &quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错 &quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式 &quot;no-script-url&quot;: 0,//禁止使用javascript:void(0) &quot;no-self-compare&quot;: 2,//不能比较自身 &quot;no-sequences&quot;: 0,//禁止使用逗号运算符 &quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 &quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 &quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格 &quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2] &quot;no-sync&quot;: 0,//nodejs 禁止同步方法 &quot;no-ternary&quot;: 0,//禁止使用三目运算符 &quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格 &quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super &quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;; &quot;no-undef&quot;: 1,//不能有未定义的变量 &quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined &quot;no-undefined&quot;: 2,//不能使用undefined &quot;no-unexpected-multiline&quot;: 2,//避免多行表达式 &quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾 &quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; &quot;no-unreachable&quot;: 2,//不能有无法执行的代码 &quot;no-unused-expressions&quot;: 2,//禁止无用的表达式 &quot;no-unused-vars&quot;: [2, {&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;}],//不能有声明后未被使用的变量或参数 &quot;no-use-before-define&quot;: 2,//未定义前不能使用 &quot;no-useless-call&quot;: 2,//禁止不必要的call和apply &quot;no-void&quot;: 2,//禁用void操作符 &quot;no-var&quot;: 0,//禁用var，用let和const代替 &quot;no-warning-comments&quot;: [1, { &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; }],//不能有警告备注 &quot;no-with&quot;: 2,//禁用with &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格 &quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来 &quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号 &quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter &quot;block-scoped-var&quot;: 0,//块语句中使用var &quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格 &quot;callback-return&quot;: 1,//避免多次调用回调什么的 &quot;camelcase&quot;: 2,//强制驼峰法命名 &quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号 &quot;comma-spacing&quot;: 0,//逗号前后的空格 &quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾 &quot;complexity&quot;: [0, 11],//循环复杂度 &quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的 &quot;consistent-return&quot;: 0,//return 后面是否允许省略 &quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名 &quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super &quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if(){} 中的{} &quot;default-case&quot;: 2,//switch语句最后必须有default &quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾 &quot;dot-notation&quot;: [0, { &quot;allowKeywords&quot;: true }],//避免不必要的方括号 &quot;eol-last&quot;: 0,//文件以单一的换行符结束 &quot;eqeqeq&quot;: 2,//必须使用全等 &quot;func-names&quot;: 0,//函数表达式必须有名字 &quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式 &quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格 &quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤 &quot;handle-callback-err&quot;: 0,//nodejs 处理错误 &quot;id-length&quot;: 0,//变量名长度 &quot;indent&quot;: [2, 4],//缩进风格 &quot;init-declarations&quot;: 0,//声明时必须赋初值 &quot;key-spacing&quot;: [0, { &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true }],//对象字面量中冒号的前后空格 &quot;lines-around-comment&quot;: 0,//行前/行后备注 &quot;max-depth&quot;: [0, 4],//嵌套块深度 &quot;max-len&quot;: [0, 80, 4],//字符串最大长度 &quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度 &quot;max-params&quot;: [0, 3],//函数最多只能有3个参数 &quot;max-statements&quot;: [0, 10],//函数内最多有几个声明 &quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 &quot;new-parens&quot;: 2,//new时必须加小括号 &quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行 &quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格 &quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法 &quot;one-var&quot;: 1,//连续声明 &quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的 &quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首 &quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行 &quot;prefer-const&quot;: 0,//首选const &quot;prefer-spread&quot;: 0,//首选展开运算 &quot;prefer-reflect&quot;: 0,//首选Reflect的方法 &quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 ` “” ‘’` &quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号 &quot;radix&quot;: 2,//parseInt必须指定第二个参数 &quot;id-match&quot;: 0,//命名检测 &quot;require-yield&quot;: 0,//生成器函数必须有yield &quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾 &quot;semi-spacing&quot;: [0, {&quot;before&quot;: false, &quot;after&quot;: true}],//分号前后空格 &quot;sort-vars&quot;: 0,//变量声明时排序 &quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格 &quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块{前面要不要有空格 &quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格 &quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格1.&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格 &quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格 &quot;space-unary-ops&quot;: [0, { &quot;words&quot;: true, &quot;nonwords&quot;: false }],//一元运算符的前/后要不要加空格 &quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的 &quot;strict&quot;: 2,//使用严格模式 &quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN() &quot;valid-jsdoc&quot;: 0,//jsdoc规则 &quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值 &quot;vars-on-top&quot;: 2,//var必须放在作用域顶部1.&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格 &quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来 &quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件 ESLint官网：https://eslint.org/docs/user-guide/configuring]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[error: No ESLint configuration found]]></title>
    <url>%2F2018%2F07%2Feslinterror.html</url>
    <content type="text"><![CDATA[ESLint使用的时候报错：error: No ESLint configuration found在项目部署中出现报错error: No ESLint configuration found，编辑器vscode。 解决方案：造成这种报错的原因是因为项目中缺少.eslintrc.js文件。添加上就可以了。 添加.eslintrc.js文件方法： 手动添加，直接手动添加.eslintrc.js文件在项目中，并进行相应的配置就行了。 使用命令添加，如果eslint是全局安装的话，使用命令eslint –init安装。 配置信息（简单版）code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354module.exports = &#123;"env": &#123; "browser": true, "es6": true, "node": true&#125;,"extends": "eslint:recommended","parserOptions": &#123; "ecmaVersion": 2015, "sourceType": "module"&#125;,"rules": &#123; // 缩进 "indent": [ "error", 4 //我的是编辑器自动格式化，不是使用tabs，而是四个空格 ], "linebreak-style": [ "error", "windows" ], // 引号 "quotes": [ 1, "single" ], // 分号结尾 "semi": [ "error", "always" ], "no-unused-vars": [2, &#123; // 允许声明未使用变量 "vars": "local", // 参数不检查 "args": "none" &#125;], // 最大空行100 "no-multiple-empty-lines": [0, &#123; "max": 100 &#125;], "no-mixed-spaces-and-tabs": [0], //不能使用console "no-console": 'off', //未定义变量不能使用 "no-undef": 0, //一行结束后面不要有空格 "no-trailing-spaces": 1, //强制驼峰法命名 "camelcase": 2, //对象字面量项尾不能有逗号 "comma-dangle": [2, "never"], //this别名 "consistent-this": [2, "that"],&#125;&#125;; 说明： &quot;no-undef&quot;: 0,和&quot;no-undef&quot;: &#39;off&#39;,一样，表示关闭该功能 &quot;no-undef&quot;: 1, 表示仅提示 &quot;no-undef&quot;: 2, 表示报错配置信息（完整版）见下一篇文章]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义右键菜单——复制到粘贴板]]></title>
    <url>%2F2018%2F07%2Fcustomright.html</url>
    <content type="text"><![CDATA[需求： 鼠标在li标签上点击右键出现菜单，主要是复制等功能 屏蔽浏览器默认右键点击事件 右键菜单出现在鼠标点击的位置 点击屏幕其他位置菜单消失 点击之后有回调 实现：使用jQuery - 右键菜单插件contextMenu jquery.contextMenu.js 和 jquery.contextMenu.css，同时 contextMenu 依赖 jQuery。 初始化插件code： 1234567891011121314151617$.contextMenu(&#123; selector: &apos;li&apos;, callback: function(key, options) &#123; var Url2 = $(this).text().trim(); var oInput = document.createElement(&apos;input&apos;); oInput.value = Url2; document.body.appendChild(oInput); oInput.select(); // 选择对象 document.execCommand(&quot;Copy&quot;); // 执行浏览器复制命令 oInput.className = &apos;oInput&apos;; oInput.style.display = &apos;none&apos;; alert(&apos;成功复制到粘贴板&apos;); &#125;, items: &#123; &quot;copy&quot;: &#123; name: &quot;复制&quot;, icon: &quot;copy&quot; &#125;, &#125; &#125;); 搞定！成功复制到粘贴板。插件GitHub 主页使用方法 使用原生js手撸一个直接上代码：code： 123456&lt;div id=&quot;Rmenu&quot;&gt; &lt;ul&gt; &lt;li&gt;复制&lt;/li&gt; &lt;li&gt;删除&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930* &#123; margin: 0; padding: 0; &#125; #Rmenu &#123; width: 80px; background: #00AAAA; position: absolute; display: none; color: #fff; text-align: center; border-radius: 5px; cursor: pointer; -moz-box-shadow: 2px 2px 20px #333333; -webkit-box-shadow: 2px 2px 20px #333333; box-shadow: 2px 2px 20px #333333; &#125; #Rmenu ul li:hover &#123; font-size: 17px; background-color: #E1B700; &#125; #Rmenu ul li &#123; border-radius: 5px; list-style: none; margin: 5px; font-size: 16px; &#125; 123456789101112131415161718window.onload = function() &#123; var menu = document.getElementById("Rmenu"); document.oncontextmenu = function(ev) &#123; var ev = ev || event; menu.style.display = "block"; menu.style.left = ev.clientX + "px"; menu.style.top = ev.clientY + "px"; //阻止默认右键事件 return false; &#125; document.onclick = function(e) &#123; //click事件可以关闭右键菜单 if (e.target.tagName.toLowerCase() === 'li') &#123; console.log("您点击的是：" + e.target.outerText); &#125; menu.style.display = "none"; &#125; &#125; result：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的html、css以及javascript兼容方案]]></title>
    <url>%2F2017%2F11%2Fjrx.html</url>
    <content type="text"><![CDATA[Html&amp;CSS部分：audio&amp;video 一般的做法： 1&lt;video controls="controls" autoplay="autoplay" width="512" height="288" src="myvideo.mp4"&gt;&lt;/video&gt; 更好的做法： 1234567891011&lt;video width="512" height="288"&gt; &lt;source src="myvideo.mp4" type="video/mp4"&gt;&lt;/source&gt; &lt;source src="myvideo.ogv" type="video/ogg"&gt;&lt;/source&gt; &lt;source src="myvideo.webm" type="video/webm"&gt;&lt;/source&gt; &lt;object width="512" height="288" type="application/x-shockwave-flash" data="myvideo.swf"&gt; &lt;param name="movie" value="myvideo.swf" /&gt; &lt;param name="flashvars" value="autostart=true&amp;file=myvideo.swf" /&gt; &lt;/object&gt; 当前浏览器不支持 video直接播放，点击这里下载视频： &lt;a href="myvideo.webm"&gt;下载视频&lt;/a&gt;&lt;/video&gt; display:inline-block;在ie6、ie7下只有设置在默认显示方式为inline的元素上才会生效，请实现兼容ie6、ie7的通用的方式。 解决方案： 123display: inline-block;*display: inline;*zoom: 1; 通过 zoom: 1; 去触发hasLayout的行为，然后通过 display: inline; 去支持IE7及以下版本（高版本会直接使用display: inline-block;） 当hasLayout和inline在一起的时候，就触发了inline-block的行为在IE7及以下版本。 ul和ol列表缩进消除ul、ol等列表的缩进时，样式应写成：list-style:none;margin:0px;padding:0px;其中margin属性对IE有效，padding属性对FireFox有效。在IE中，设置margin:0px可以去除列表的上下左右缩进、空白以及列表编号或圆点，设置padding对样式没有影响；在 Firefox 中，设置margin:0px仅仅可以去除上下的空白，设置padding:0px后仅仅可以去掉左右缩进，还必须设置list- style:none才能去除列表编号或圆点。也就是说，在IE中仅仅设置margin:0px即可达到最终效果，而在Firefox中必须同时设置margin:0px、padding:0px以及list-style:none三项才能达到最终效果。 border-radius语法： border-radius：[&lt;length&gt;|&lt;percentage&gt; ]{1,4}[/[&lt;length&gt;|&lt;percentage&gt;]{1,4}]? length：用长度值设置对象的圆角半径长度。不允许负值percentage：用百分比设置对象的圆角半径长度。不允许负值border-radius:20px; 兼容方法： 低版本的chrome:-webkit-border-radius:10px; 低版本的firefox:-moz-border-radius:10px; ie7以下版本不支持圆角 IE6/7/8:引入ie-css3兼容文件,不支持除了黑色(#000)以外的其他颜色 IE的双边距bug设置为float的div在ie下设置的margin会加倍。这是一个ie6都存在的bug。 解决方案 在这个div里面加上display:inline; 例如： 1&lt;div id=”div1”&gt;&lt;/div&gt; 123456789.div2 &#123; background-color: red; float: left; width: 150px; height: 150px; margin: 5px 0 5px 100px; display:inline;&#125; box-shadow语法： box-shadow：none|[inset?&amp;&amp;[&lt;offset-x&gt;&lt;offset-y&gt;&lt;blur-radius&gt;?&lt;spread-radius&gt;?&lt;color&gt;?]]# inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影offset-x: 这是第一个length值设置水平偏移量，如果是负值则阴影位于元素左边。offset-y: 这是第二个length值设置垂直偏移量，如果是负值则阴影位于元素上面。blur-radius:这是第三个length值。值越大，糊糊面积越大，阴影就越大越淡。 不能为负值。默认为0，此时阴影边缘锐利。color：设置对象的阴影的颜色。 实例：12345678.div2 &#123; background-color: red; float: left; width: 150px; height: 150px; margin: 5px 0 5px 100px; box-shadow: 20px 20px 10px #ccc;&#125; IE7、8：解决方案： 第一种方法： filter:progid:dXImageTransform.Microsoft.DropShadow(color=#cccccc,offX=20,offY=20,positives=true); 第二种方法： filter:progid:DXImageTransform.Microsoft.Shadow(color=&#39;#cccccc&#39;,Direction=&#39;120&#39;,Strength=&#39;20&#39;); 两种方法都存在的缺点：阴影不能边缘模糊 transform兼容方法： .transform{ -webkit-transform: x,y; -moz-transform: x,y; -ms-transform: x,y; -o-transform: x,y; transform: x,y; } 垂直翻转： transform:rotateY(180deg) IE8及以下：用IE滤镜 filter:fliph;//水平翻转 filter:flipv;//垂直翻转 JavaScript部分：JSON.stringify函数在ie6/7中不支持，如何兼容？12345678910111213141516171819202122232425262728293031323334353637if(!window.JSON) &#123; window.JSON = &#123; parse: function(sJson) &#123; return eval("(" + sJSON + ")"); &#125;, stringify: function(obj) &#123; var result = ""; for(var key in obj) &#123; if(typeof obj[key] == "string") &#123; result += "\"" + key + "\":\"" + obj[key] + "\","; &#125; else if(obj[key] instanceof RegExp) &#123; result += "\"" + key + "\":&#123;&#125;,"; &#125; else if(typeof obj[key] == "undefined" || obj[key] instanceof Function) &#123;&#125; else if(obj[key] instanceof Array) &#123; result += "\"" + key + "\":["; var arr = obj[key]; for(var item in arr) &#123; if(typeof arr[item] == "string") &#123; result += "\"" + arr[item] + "\","; &#125; else if(arr[item] instanceof RegExp) &#123; result += "&#123;&#125;,"; &#125; else if(typeof arr[item] == "undefined" || arr[item] instanceof Function) &#123; result += null + ","; &#125; else if(arr[item] instanceof Object) &#123; result += this.stringify(arr[item]) + ","; &#125; else &#123; result += arr[item] + ","; &#125; &#125; result = result.slice(0, -1) + "]," &#125; else if(obj[key] instanceof Object) &#123;&#125; else &#123; result += "\"" + key + "\":" + obj[key] + ","; &#125; &#125; return "&#123;" + result.slice(0, -1) + "&#125;"; &#125; &#125;;&#125; element.children能够获取元素的元素子节点，但是低版本的ie不支持，如何在低版本的ie上兼容类似的功能。1234567891011121314151617181920212223242526272829303132333435function getElementChildren(element)&#123; if(!element.children)&#123; var element_arr = []; var list = element.ChildNodes; for(i=0; i&lt;list.length; i++)&#123; if (list[i].nodetype==1) &#123; element_arr.push(list[i]); &#125; &#125; return element_arr; &#125; else&#123; return element.children; &#125;&#125; ``` ### element.dataset能够获取元素的自定义属性，但是低版本的ie不支持，如何在低版本的ie上兼容类似的功能。```javascriptfunction dataset(element) &#123; var obj = &#123;&#125;; if(element.dataset) &#123; return element.dataset; &#125; else &#123; // console.log(element.attributes); for(var i = 0; i &lt; element.attributes.length; i++) &#123; var key = element.attributes[i].nodeName; if(/^data-\w+$/.test(key)) &#123; //判断是否以data-开头的属性名 var value = element.attributes[i].nodeValue; //值 var keyName = key.match(/^data-(\w+)/)[1]; //键名 obj[keyName] = value; //对象添加属性 &#125; &#125; &#125; return obj;&#125; window.getComputedStyle能够获取元素的实际样式，但是低版本的ie8及以下不支持，如何在低版本的ie上兼容类似的功能。1234567891011//获取当前样式function getStyle(element, att) &#123; //特性侦测 if(window.getComputedStyle) &#123; //优先使用W3C规范 return window.getComputedStyle(element)[att]; &#125; else &#123; //针对IE9以下兼容 return element.currentStyle[att]; &#125;&#125; 文中所有的demo下载地址：https://github.com/usecodelee/compatibility]]></content>
      <categories>
        <category>兼容</category>
      </categories>
      <tags>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sprite 从PS切图到具体实现完整过程]]></title>
    <url>%2F2017%2F10%2Fsprite.html</url>
    <content type="text"><![CDATA[sprite的优点有以下方面： 减少http请求次数。 减少图片字节数（很多人有疑问为什么合在一起还会降低字节数，图片明明变大了。原因是这样的：每个图片都是有固定的格式的，包括图像头、版本号、appo块等等，这些属性都会占一定的字节数。因此合在一起回降低字节数）。 缺点： 维护成本增加，比如要修改或增加一个图标需要修改整张sprite图。 解决这一缺点的方法是： 增加图标摆放的间隙。根据图片大小一般留20-40px的间隙。 图片合并的基本原则： 色彩相近的合在一起 大小相近的合在一起 属于同一页面的合在一起 有点击或hover状态改变的图标放在一起 具体实现：PS切图：首先合并图层，然后使用举行选框工具选出需要切出的图标，接着使用魔棒工具+Alt去除多余的部分。最后保存到新建的图层。我这里使用的是Adobe公司的部分软件logo得到的结果如下： CSS布局： HTML:使用ul_li标签布局 CSS：加上一些CSS属性之后 使用before选择器，为每个li标签加上background-position属性之后： 详细解读：以PS为例。123.ps:before&#123; background-position:-45px-21px; &#125; 其中background-position的第一个值表示PS图标左边距离整张sprite图左边的距离，第二个值表示PS图标上边距离整张sprite图上边的距离。直接上图： 但是我们看见实际运用的时候的值是负数，这就相当于把整张sprite往左边移动45px，往上移动21px。这些值可以用PS直接测量出来。 最后附上demo源码下载地址：https://github.com/usecodelee/sprite]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Present轻量级加密算法C#实现]]></title>
    <url>%2F2017%2F10%2Fpresent.html</url>
    <content type="text"><![CDATA[Present轻量级加密算法 是不是看得一头雾水，那就对了，当初我们拿到的时候也是这样子。（这时候我就想起来我们老师说的：“那你就看下我写的密码学科普书《密码学趣味之旅》吧”，当当网：http://product.dangdang.com/23756886.html 当然你也可以直接联系我我寄一本给你，毕竟我们班就有四十本）。 还有这篇介绍present的文章我这儿也有英文原版，地址：https://github.com/usecodelee/present/blob/master/present_spec.pdf 当然，我们最后也是做出一些东西的： 论文里面的测试案例： 运行结果： 这是用C# GUI编程写出来的，毕竟老师说了不想只看那个小黑框。 最后再来重点啦！源码地址：https://github.com/usecodelee/present]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
